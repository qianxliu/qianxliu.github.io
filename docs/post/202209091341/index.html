<!DOCTYPE html><head><title>Leetcode 23 - Two Pointer and C++ priority_queue lambda - 兴趣使然的无名小站</title><meta name="description" content=""><script src="/bundle.js" onload="[].flat||(location='/update.html')"></script></head><main><article><h1>Leetcode 23 - Two Pointer and C++ priority_queue lambda</h1><h1 id="leetcode-23---two-pointer-and-c-priority_queue-lambda">Leetcode 23 - Two Pointer and C++ priority_queue lambda</h1><pre><code class="language-cpp">class Solution {
public:
    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {
        // struct must init correct
        ListNode* dummy = new ListNode(0);
        auto cmp = [](ListNode* &amp;a, ListNode* &amp;b)
        {
            return a-&gt;val &gt; b-&gt;val;
        };

        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(cmp)&gt; pq(cmp);

        for (ListNode* &amp;list : lists)
        {
            if (list != nullptr)    pq.push(list);
        }
        ListNode* node = dummy;
        while(!pq.empty())
        {
            node-&gt;next = pq.top();
            node = node-&gt;next;
            pq.pop();
            if (node-&gt;next != nullptr)   pq.push(node-&gt;next);
        }
        return dummy-&gt;next;
    }
};</code></pre><p>编写时问题在于ListNode* dummy = new ListNode(0); 本来用ListNode* dummy，但是指针必须指向一个初始化的结构体</p></article></main>