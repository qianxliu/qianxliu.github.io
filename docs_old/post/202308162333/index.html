<!DOCTYPE html><head><title>图与树（CS） - 兴趣使然的无名小站</title><meta name="description" content=""><script src="/bundle.js" onload="[].flat||(location='/update.html')"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/atom-one-dark.min.css"></head><main><article><h1>图与树（CS）</h1><blockquote>
<p>好长时间没更新博客了……最近确实发生了不少事情，导致更新不了
It&#39;s been a long time to not update my blog……Recently actually many things happen, so that I couldn&#39;t have time to draw something.</p>
</blockquote>
<h1>Graph and Tree(CS)</h1>
<h1>图与树（CS）</h1>
<h2>Graph theory(Math)</h2>
<h2>图论(数学)</h2>
<p>The paper written by <strong>Leonhard Euler</strong> on the Seven Bridges of Königsberg and published in 1736 is regarded as the first paper in the history of graph theory.
莱昂哈德·欧拉于1736年发表的关于柯尼斯堡七桥的论文被认为是图论史上的第一篇论文。
A graph (sometimes called an undirected graph to distinguish it from a directed graph, or a simple graph to distinguish it from a multigraph) is a pair <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G = (V, E)</annotation></semantics></math></span>, where <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span> is a <strong>set</strong> whose elements are called vertices (singular: vertex), and E is a set of paired vertices, whose elements are called edges (sometimes links or lines). 
一个图（有时称为无向图以将其与有向图区分开来，或称为简单图以将它与多重图区分开来）是一对<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mtext>（</mtext><mi>V</mi><mtext>，</mtext><mi>E</mi><mtext>）</mtext></mrow><annotation encoding="application/x-tex">G=（V，E）</annotation></semantics></math></span>，其中<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span>是一个<strong>集合</strong>，其元素称为顶点（单数：顶点），E是一组成对的顶点，其元素也称为边（有时为链接或线）。
<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span>, a set of vertices (also called nodes or points);
<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>⊆</mo><mo stretchy="false">{</mo><mo stretchy="false">{</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">}</mo><mo>∣</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi>V</mi><mtext>  </mtext><mtext>and</mtext><mtext>  </mtext><mi>x</mi><mo mathvariant="normal">≠</mo><mi>y</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">E\subseteq \{\{x,y\}\mid x,y\in V\;{\textrm {and}}\;x\neq y\}</annotation></semantics></math></span>, a set of edges (also called links or lines), which are unordered pairs of vertices (that is, an edge is associated with two distinct vertices).</p>
<h2>Breadth-First Search BFS</h2>
<h2>广度优先搜索</h2>
<pre><code class="hljs language-cpp">queue&lt;<span class="hljs-type">int</span>&gt; q;
<span class="hljs-type">bool</span> visited[N];
<span class="hljs-type">int</span> dist[N];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
</span>{
    visited[x] = <span class="hljs-literal">true</span>;
    q.<span class="hljs-built_in">push</span>(x);
    dist[x] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())
    {
        <span class="hljs-type">int</span> s = q.<span class="hljs-built_in">front</span>();
        q.<span class="hljs-built_in">pop</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : adj[s])
        {
            <span class="hljs-keyword">if</span> (visited[i]) <span class="hljs-keyword">continue</span>;
            visited[i] = <span class="hljs-literal">true</span>;
            <span class="hljs-comment">// i, s</span>
            dist[i] = dist[s] + <span class="hljs-number">1</span>;
            q.<span class="hljs-built_in">push</span>(i);
        }
    }
}
</code></pre><h2>Binary Tree(Recursion, CS in Math)</h2>
<h2>二叉树(Recursion, CS in Math)</h2>
<p>在数学中是一种无向无环图(不是DAG)。必须递归定义。
A type of undirected acyclic graph in Math(not DAG). Must be defined by recursion.
（非空）二叉树是元组<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>L</mi><mo separator="true">,</mo><mi>S</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(L,S,R)</annotation></semantics></math></span>，其中<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span>和<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span>是二叉树或空集，<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span>是包含根的单例集。
A (nonempty) binary tree is a tuple <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>L</mi><mo separator="true">,</mo><mi>S</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(L, S, R)</annotation></semantics></math></span>, where <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span>and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span>are binary trees or empty sets, and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span>is a singleton containing roots.</p>
<p>Defining the binary tree as triplet <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mn>1</mn><mo separator="true">,</mo><mi>E</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(V, E1, E2)</annotation></semantics></math></span>, where <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mn>1</mn><mo>∪</mo><mi>E</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(V, E1 ∪ E2)</annotation></semantics></math></span> is a rooted tree.
<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub><mo>⊆</mo><mo stretchy="false">{</mo><mo stretchy="false">{</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">}</mo><mo>∣</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi>V</mi><mtext>  </mtext><mtext>and</mtext><mtext>  </mtext><mi>x</mi><mo mathvariant="normal">≠</mo><mi>y</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">E_1\subseteq \{\{x,y\}\mid x,y\in V\;{\textrm {and}}\;x\neq y\}</annotation></semantics></math></span>
<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>2</mn></msub><mo>⊆</mo><mo stretchy="false">{</mo><mo stretchy="false">{</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">}</mo><mo>∣</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi>V</mi><mtext>  </mtext><mtext>and</mtext><mtext>  </mtext><mi>x</mi><mo mathvariant="normal">≠</mo><mi>y</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">E_2\subseteq \{\{x,y\}\mid x,y\in V\;{\textrm {and}}\;x\neq y\}</annotation></semantics></math></span>
<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>E</mi><mn>2</mn></msub><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">E_1 ∩ E_2 = \emptyset</annotation></semantics></math></span>
and also requiring that for all <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>∈</mo><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn></mrow></mrow><annotation encoding="application/x-tex">j ∈ { 1, 2 }</annotation></semantics></math></span> every node has at most one <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">E_j</annotation></semantics></math></span> child.
This definition is not very strict.</p>
<h2>Sequence traversal of binary trees</h2>
<h2>二叉树的层序遍历</h2>
<pre><code class="hljs language-cpp">    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode *root)
    {
        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;
        <span class="hljs-keyword">if</span> (!root)
            <span class="hljs-keyword">return</span> res;

        queue&lt;TreeNode *&gt; q;
        q.<span class="hljs-built_in">push</span>(root);

        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())
        {
            <span class="hljs-type">int</span> sz = q.<span class="hljs-built_in">size</span>();
            vector&lt;<span class="hljs-type">int</span>&gt; level;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; ++i)
            {
                TreeNode *cur = q.<span class="hljs-built_in">front</span>();
                q.<span class="hljs-built_in">pop</span>();
                level.<span class="hljs-built_in">push_back</span>(cur-&gt;val);
                <span class="hljs-keyword">if</span> (cur-&gt;left)
                    q.<span class="hljs-built_in">push</span>(cur-&gt;left);
                <span class="hljs-keyword">if</span> (cur-&gt;right)
                    q.<span class="hljs-built_in">push</span>(cur-&gt;right);
            }
            res.<span class="hljs-built_in">push_back</span>(level);
        }
        <span class="hljs-keyword">return</span> res;
  }
</code></pre></article></main>