<!DOCTYPE html><head><title>数据结构珠玑——二叉树(1) - 兴趣使然的无名小站</title><meta name="description" content=""><script src="/bundle.js" onload="[].flat||(location='/update.html')"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/atom-one-dark.min.css"></head><main><article><h1>数据结构珠玑——二叉树(1)</h1><h1>数据结构珠玑——二叉树(1)</h1>
<p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal">https://leetcode-cn.com/problems/binary-tree-preorder-traversal</a>
<img src="https://img2020.cnblogs.com/blog/2051127/202112/2051127-20211209200546971-917863101.png" alt="">
<img src="https://img2020.cnblogs.com/blog/2051127/202112/2051127-20211209200647334-1296455794.png" alt=""></p>
<p>本代码全网最快，100%几乎完全不是运气。</p>
<pre><code class="hljs language-cpp"><span class="hljs-comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; traversal)</span>
    </span>{
        <span class="hljs-keyword">if</span>(root)
        {
            traversal.<span class="hljs-built_in">emplace_back</span>(root-&gt;val);
            <span class="hljs-built_in">preorder</span>(root-&gt;left, traversal);
            <span class="hljs-built_in">preorder</span>(root-&gt;right, traversal);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        vector&lt;<span class="hljs-type">int</span>&gt; traversal;
        <span class="hljs-built_in">preorder</span>(root, traversal);
        <span class="hljs-keyword">return</span> traversal;
    }
};
</code></pre><p>这个代码我觉得没必要讲了，但是中间确实有几部分和传统做法不同，从而比大多做法大幅提高了性能。</p>
<p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal">https://leetcode-cn.com/problems/binary-tree-inorder-traversal</a>
<img src="https://img2020.cnblogs.com/blog/2051127/202112/2051127-20211209212129365-613648686.png" alt=""></p>
<p>中序遍历</p>
<pre><code class="hljs language-cpp"><span class="hljs-comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; traversal)</span>
    </span>{
        <span class="hljs-keyword">if</span> (root)
        {
            <span class="hljs-built_in">inorder</span>(root-&gt;left, traversal);
            traversal.<span class="hljs-built_in">emplace_back</span>(root-&gt;val);
            <span class="hljs-built_in">inorder</span>(root-&gt;right, traversal);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        vector&lt;<span class="hljs-type">int</span>&gt; traversal;
        <span class="hljs-built_in">inorder</span>(root, traversal);
        <span class="hljs-keyword">return</span> traversal;
    }
};
</code></pre><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal">https://leetcode-cn.com/problems/binary-tree-postorder-traversal</a>
<img src="https://img2020.cnblogs.com/blog/2051127/202112/2051127-20211209212506392-1975522678.png" alt=""></p>
<p>后序遍历</p>
<pre><code class="hljs language-cpp"><span class="hljs-comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; traversal)</span>
    </span>{
        <span class="hljs-keyword">if</span> (root)
        {
            <span class="hljs-built_in">postorder</span>(root-&gt;left, traversal);
            <span class="hljs-built_in">postorder</span>(root-&gt;right, traversal);
            traversal.<span class="hljs-built_in">emplace_back</span>(root-&gt;val);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        vector&lt;<span class="hljs-type">int</span>&gt; traversal;
        <span class="hljs-built_in">postorder</span>(root, traversal);
        <span class="hljs-keyword">return</span> traversal;
    }
};
</code></pre></article></main>